<!-- build time:Sat Nov 13 2021 13:49:32 GMT+0800 (中国标准时间) --><!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><link rel="apple-touch-icon" sizes="76x76" href="/img/apple-touch-icon.png"><link rel="icon" type="image/png" href="/img/favicon.png"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no,shrink-to-fit=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests"><meta name="keywords" content="前端博客,博客,物理竞赛,JavaScript,Java,Android,安卓,科技,数码,高中,学生,生活"><meta name="theme-color" content="#1a73e8"><meta name="description" content="维他入我心的个人博客"><meta name="author" content="维他入我心"><meta name="keywords" content="前端博客,博客,物理竞赛,JavaScript,Java,Android,安卓,科技,数码,高中,学生,生活"><title>Java代码精简之道 ~ 维他入我心</title><link rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/4.0.0/github-markdown.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1067060_qzomjdt8bmp.css"><link rel="stylesheet" href="/lib/prettify/github-v2.min.css"><link rel="stylesheet" href="/css/main.css"><link defer rel="stylesheet" href="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.css"><meta name="generator" content="Hexo 4.2.0"><link rel="alternate" href="/atom.xml" title="维他入我心" type="application/atom+xml"></head><body><div id="snackbar"></div><header id="header" style="height:80vh"><nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class="container"><a class="navbar-brand" href="/">&nbsp;<strong>维他入我心</strong>&nbsp;</a> <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item"><a class="nav-link ripple-effect" href="/">首页</a></li><li class="nav-item"><a class="nav-link ripple-effect" href="/archives/">归档</a></li><li class="nav-item"><a class="nav-link ripple-effect" href="/categories/">分类</a></li><li class="nav-item"><a class="nav-link ripple-effect" href="/tags/">标签</a></li><li class="nav-item"><a class="nav-link ripple-effect" href="/links/">友链</a></li><li class="nav-item"><a class="nav-link ripple-effect" href="/about/">关于</a></li><li class="nav-item"><a class="nav-link ripple-effect" href="/tools/">工具</a></li><li class="nav-item"><a class="nav-link ripple-effect" href="/RSS/">RSS</a></li><li class="nav-item" id="search-btn"><a class="nav-link ripple-effect" data-toggle="modal" data-target="#modalSearch">&nbsp;&nbsp;<i class="iconfont icon-search"></i>&nbsp;&nbsp;</a></li></ul></div></div></nav><div class="view intro-2" id="background" parallax="true" style="background:center center/cover no-repeat;background-size:cover"><div class="full-bg-img"><div class="mask flex-center"><div class="container text-center white-text fadeInUp"><span class="h2" id="subtitle"></span><p class="mt-3 post-meta">星期日, 五月 10日 2020, 5:19 下午</p><p class="mt-1"><span class="post-meta">7.4k 字 </span><span class="post-meta">219 分钟</span></p></div></div></div></div></header><main><div class="container-fluid"><div class="row"><div class="d-none d-lg-block col-lg-2"></div><div class="col-lg-8 nopadding-md"><div class="container nopadding-md" id="board-ctn"><div class="py-5" id="board"><div class="post-content mx-auto" id="post"><div class="markdown-body"><blockquote><p>以下文章来源于阿里巴巴中间件 ，作者常意</p></blockquote><p>作者 | 常意</p><p>来源 | 阿里巴巴中间件（ID：Aliware_2018）</p><p>古语有云：</p><blockquote><p>道为术之灵，术为道之体；以道统术，以术得道。</p></blockquote><p>其中：“道”指“规律、道理、理论”，“术”指“方法、技巧、技术”。意思是：“道”是“术”的灵魂，“术”是“道”的肉体；可以用“道”来统管“术”，也可以从“术”中获得“道”。</p><p>在拜读大佬“孤尽”的文章《Code Review是苦涩但有意思的修行》时，感受最深的一句话就是：“优质的代码一定是少即是多的精兵原则”，这就是大佬的代码精简之“道”。</p><p>工匠追求“术”到极致，其实就是在寻“道”，且离悟“道”也就不远了，亦或是已经得道，这就是“工匠精神”——一种追求“以术得道”的精神。如果一个工匠只满足于“术”，不能追求“术”到极致去悟“道”，那只是一个靠“术”养家糊口的工匠而已。作者根据多年来的实践探索，总结了大量的 Java 代码精简之“术”，试图阐述出心中的 Java 代码精简之“道”。</p><h2 id="利用语法"><a class="markdownIt-Anchor" href="#利用语法"></a> <strong>利用语法</strong></h2><h3 id="11利用三元表达式"><a class="markdownIt-Anchor" href="#11利用三元表达式"></a> <strong>1.1.利用三元表达式</strong></h3><p><strong>普通：</strong></p><pre class="highlight"><code class="java">String title;
<span class="hljs-keyword">if</span> (isMember(phone)) {
    title = <span class="hljs-string">"会员"</span>;
} <span class="hljs-keyword">else</span> {
    title = <span class="hljs-string">"游客"</span>;
}
</code></pre><p><strong>精简：</strong></p><pre class="highlight"><code class="java">String title = isMember(phone) ? <span class="hljs-string">"会员"</span> : <span class="hljs-string">"游客"</span>;
</code></pre><p>注意：对于包装类型的算术计算，需要注意避免拆包时的空指针问题。</p><h3 id="12利用-for-each-语句"><a class="markdownIt-Anchor" href="#12利用-for-each-语句"></a> <strong>1.2.利用 for-each 语句</strong></h3><p>从 Java 5 起，提供了 for-each 循环，简化了数组和集合的循环遍历。 for-each 循环允许你无需保持传统 for 循环中的索引就可以遍历数组，或在使用迭代器时无需在 while 循环中调用 hasNext 方法和 next 方法就可以遍历集合。</p><p><strong>普通：</strong></p><pre class="highlight"><code class="java"><span class="hljs-keyword">double</span>[] values = ...;
<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; values.length; i++) {
    <span class="hljs-keyword">double</span> value = values[i];
    <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> 处理value</span>
}

List&lt;Double&gt; valueList = ...;
Iterator&lt;Double&gt; iterator = valueList.iterator();
<span class="hljs-keyword">while</span> (iterator.hasNext()) {
    Double value = iterator.next();
    <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> 处理value</span>
}
</code></pre><p><strong>精简：</strong></p><pre class="highlight"><code class="java"><span class="hljs-keyword">double</span>[] values = ...;
<span class="hljs-keyword">for</span>(<span class="hljs-keyword">double</span> value : values) {
    <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> 处理value</span>
}

List&lt;Double&gt; valueList = ...;
<span class="hljs-keyword">for</span>(Double value : valueList) {
    <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> 处理value</span>
}
</code></pre><h3 id="13利用-try-with-resource-语句"><a class="markdownIt-Anchor" href="#13利用-try-with-resource-语句"></a> <strong>1.3.利用 try-with-resource 语句</strong></h3><p>所有实现 Closeable 接口的“资源”，均可采用 try-with-resource 进行简化。</p><p><strong>普通：</strong></p><pre class="highlight"><code class="java">BufferedReader reader = <span class="hljs-keyword">null</span>;
<span class="hljs-keyword">try</span> {
    reader = <span class="hljs-keyword">new</span> BufferedReader(<span class="hljs-keyword">new</span> FileReader(<span class="hljs-string">"cities.csv"</span>));
    String line;
    <span class="hljs-keyword">while</span> ((line = reader.readLine()) != <span class="hljs-keyword">null</span>) {
        <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> 处理line</span>
    }
} <span class="hljs-keyword">catch</span> (IOException e) {
    log.error(<span class="hljs-string">"读取文件异常"</span>, e);
} <span class="hljs-keyword">finally</span> {
    <span class="hljs-keyword">if</span> (reader != <span class="hljs-keyword">null</span>) {
        <span class="hljs-keyword">try</span> {
            reader.close();
        } <span class="hljs-keyword">catch</span> (IOException e) {
            log.error(<span class="hljs-string">"关闭文件异常"</span>, e);
        }
    }
}
</code></pre><p><strong>精简：</strong></p><pre class="highlight"><code class="java"><span class="hljs-keyword">try</span> (BufferedReader reader = <span class="hljs-keyword">new</span> BufferedReader(<span class="hljs-keyword">new</span> FileReader(<span class="hljs-string">"test.txt"</span>))) {
    String line;
    <span class="hljs-keyword">while</span> ((line = reader.readLine()) != <span class="hljs-keyword">null</span>) {
        <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> 处理line</span>
    }
} <span class="hljs-keyword">catch</span> (IOException e) {
    log.error(<span class="hljs-string">"读取文件异常"</span>, e);
}
</code></pre><h3 id="14利用-return-关键字"><a class="markdownIt-Anchor" href="#14利用-return-关键字"></a> <strong>1.4.利用 return 关键字</strong></h3><p>利用 return 关键字，可以提前函数返回，避免定义中间变量。</p><p><strong>普通：</strong></p><pre class="highlight"><code class="java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">hasSuper</span><span class="hljs-params">(@NonNull List&lt;UserDO&gt; userList)</span> </span>{
    <span class="hljs-keyword">boolean</span> hasSuper = <span class="hljs-keyword">false</span>;
    <span class="hljs-keyword">for</span> (UserDO user : userList) {
        <span class="hljs-keyword">if</span> (Boolean.TRUE.equals(user.getIsSuper())) {
            hasSuper = <span class="hljs-keyword">true</span>;
            <span class="hljs-keyword">break</span>;
        }
    }
    <span class="hljs-keyword">return</span> hasSuper;
}
</code></pre><p><strong>精简：</strong></p><pre class="highlight"><code class="java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">hasSuper</span><span class="hljs-params">(@NonNull List&lt;UserDO&gt; userList)</span> </span>{
    <span class="hljs-keyword">for</span> (UserDO user : userList) {
        <span class="hljs-keyword">if</span> (Boolean.TRUE.equals(user.getIsSuper())) {
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
        }
    }
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
}
</code></pre><h3 id="15利用-static-关键字"><a class="markdownIt-Anchor" href="#15利用-static-关键字"></a> <strong>1.5.利用 static 关键字</strong></h3><p>利用 static 关键字，可以把字段变成静态字段，也可以把函数变为静态函数，调用时就无需初始化类对象。</p><p><strong>普通：</strong></p><pre class="highlight"><code class="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GisHelper</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">distance</span><span class="hljs-params">(<span class="hljs-keyword">double</span> lng1, <span class="hljs-keyword">double</span> lat1, <span class="hljs-keyword">double</span> lng2, <span class="hljs-keyword">double</span> lat2)</span> </span>{
        <span class="hljs-comment">// 方法实现代码</span>
    }
}

GisHelper gisHelper = <span class="hljs-keyword">new</span> GisHelper();
<span class="hljs-keyword">double</span> distance = gisHelper.distance(<span class="hljs-number">116.178692</span>D, <span class="hljs-number">39.967115</span>D, <span class="hljs-number">116.410778</span>D, <span class="hljs-number">39.899721</span>D);
</code></pre><p><strong>精简：</strong></p><pre class="highlight"><code class="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GisHelper</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">double</span> <span class="hljs-title">distance</span><span class="hljs-params">(<span class="hljs-keyword">double</span> lng1, <span class="hljs-keyword">double</span> lat1, <span class="hljs-keyword">double</span> lng2, <span class="hljs-keyword">double</span> lat2)</span> </span>{
        <span class="hljs-comment">// 方法实现代码</span>
    }
}

<span class="hljs-keyword">double</span> distance = GisHelper.distance(<span class="hljs-number">116.178692</span>D, <span class="hljs-number">39.967115</span>D, <span class="hljs-number">116.410778</span>D, <span class="hljs-number">39.899721</span>D);
</code></pre><h3 id="16利用-lambda-表达式"><a class="markdownIt-Anchor" href="#16利用-lambda-表达式"></a> <strong>1.6.利用 lambda 表达式</strong></h3><p>Java 8 发布以后，lambda 表达式大量替代匿名内部类的使用，在简化了代码的同时，更突出了原有匿名内部类中真正有用的那部分代码。</p><p><strong>普通：</strong></p><pre class="highlight"><code class="java"><span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> Runnable() {
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-comment">// 线程处理代码</span>
    }
}).start();
</code></pre><p><strong>精简：</strong></p><pre class="highlight"><code class="java"><span class="hljs-keyword">new</span> Thread(() -&gt; {
    <span class="hljs-comment">// 线程处理代码</span>
}).start();
</code></pre><h3 id="17利用方法引用"><a class="markdownIt-Anchor" href="#17利用方法引用"></a> <strong>1.7.利用方法引用</strong></h3><p>方法引用（::），可以简化 lambda 表达式，省略变量声明和函数调用。</p><p><strong>普通：</strong></p><pre class="highlight"><code class="java">Arrays.sort(nameArray, (a, b) -&gt; a.compareToIgnoreCase(b));
List&lt;Long&gt; userIdList = userList.stream()
    .map(user -&gt; user.getId())
    .collect(Collectors.toList());
</code></pre><p><strong>精简：</strong></p><pre class="highlight"><code class="java">Arrays.sort(nameArray, String::compareToIgnoreCase);
List&lt;Long&gt; userIdList = userList.stream()
    .map(UserDO::getId)
    .collect(Collectors.toList());
</code></pre><h3 id="18利用静态导入"><a class="markdownIt-Anchor" href="#18利用静态导入"></a> <strong>1.8.利用静态导入</strong></h3><p>静态导入（import static），当程序中大量使用同一静态常量和函数时，可以简化静态常量和函数的引用。</p><p><strong>普通：</strong></p><pre class="highlight"><code class="java">List&lt;Double&gt; areaList = radiusList.stream().map(r -&gt; Math.PI * Math.pow(r, <span class="hljs-number">2</span>)).collect(Collectors.toList());
...
</code></pre><p><strong>精简：</strong></p><pre class="highlight"><code class="java"><span class="hljs-keyword">import</span> <span class="hljs-keyword">static</span> java.lang.Math.PI;
<span class="hljs-keyword">import</span> <span class="hljs-keyword">static</span> java.lang.Math.pow;
<span class="hljs-keyword">import</span> <span class="hljs-keyword">static</span> java.util.stream.Collectors.toList;

List&lt;Double&gt; areaList = radiusList.stream().map(r -&gt; PI * pow(r, <span class="hljs-number">2</span>)).collect(toList());
...
</code></pre><p>注意：静态引入容易造成代码阅读困难，所以在实际项目中应该警慎使用。</p><h3 id="19利用-unchecked-异常"><a class="markdownIt-Anchor" href="#19利用-unchecked-异常"></a> <strong>1.9.利用 unchecked 异常</strong></h3><p>Java 的异常分为两类：Checked 异常和 Unchecked 异常。Unchecked 异常继承了RuntimeException ，特点是代码不需要处理它们也能通过编译，所以它们称作 Unchecked 异常。利用 Unchecked 异常，可以避免不必要的 try-catch 和 throws 异常处理。</p><p><strong>普通：</strong></p><pre class="highlight"><code class="java"><span class="hljs-meta">@Service</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserService</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">createUser</span><span class="hljs-params">(UserCreateVO create, OpUserVO user)</span> <span class="hljs-keyword">throws</span> BusinessException </span>{
        checkOperatorUser(user);
        ...
    }
    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">checkOperatorUser</span><span class="hljs-params">(OpUserVO user)</span> <span class="hljs-keyword">throws</span> BusinessException </span>{
        <span class="hljs-keyword">if</span> (!hasPermission(user)) {
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BusinessException(<span class="hljs-string">"用户无操作权限"</span>);
        }
        ...
    }
    ...
}

<span class="hljs-meta">@RestController</span>
<span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"/user"</span>)
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserController</span> </span>{
    <span class="hljs-meta">@Autowired</span>
    <span class="hljs-keyword">private</span> UserService userService;

    <span class="hljs-meta">@PostMapping</span>(<span class="hljs-string">"/createUser"</span>)
    <span class="hljs-function"><span class="hljs-keyword">public</span> Result&lt;Void&gt; <span class="hljs-title">createUser</span><span class="hljs-params">(@RequestBody @Valid UserCreateVO create, OpUserVO user)</span> <span class="hljs-keyword">throws</span> BusinessException </span>{
        userService.createUser(create, user);
        <span class="hljs-keyword">return</span> Result.success();
    }
    ...
}
</code></pre><p><strong>精简：</strong></p><pre class="highlight"><code class="java"><span class="hljs-meta">@Service</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserService</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">createUser</span><span class="hljs-params">(UserCreateVO create, OpUserVO user)</span> </span>{
        checkOperatorUser(user);
        ...
    }
    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">checkOperatorUser</span><span class="hljs-params">(OpUserVO user)</span> </span>{
        <span class="hljs-keyword">if</span> (!hasPermission(user)) {
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BusinessRuntimeException(<span class="hljs-string">"用户无操作权限"</span>);
        }
        ...
    }
    ...
}

<span class="hljs-meta">@RestController</span>
<span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"/user"</span>)
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserController</span> </span>{
    <span class="hljs-meta">@Autowired</span>
    <span class="hljs-keyword">private</span> UserService userService;

    <span class="hljs-meta">@PostMapping</span>(<span class="hljs-string">"/createUser"</span>)
    <span class="hljs-function"><span class="hljs-keyword">public</span> Result&lt;Void&gt; <span class="hljs-title">createUser</span><span class="hljs-params">(@RequestBody @Valid UserCreateVO create, OpUserVO user)</span> </span>{
        userService.createUser(create, user);
        <span class="hljs-keyword">return</span> Result.success();
    }
    ...
}
</code></pre><h2 id="利用注解"><a class="markdownIt-Anchor" href="#利用注解"></a> <strong>利用注解</strong></h2><h3 id="21利用-lombok-注解"><a class="markdownIt-Anchor" href="#21利用-lombok-注解"></a> <strong>2.1.利用 Lombok 注解</strong></h3><p>Lombok 提供了一组有用的注解，可以用来消除Java类中的大量样板代码。</p><p><strong>普通：</strong></p><pre class="highlight"><code class="java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserVO</span> </span>{
    <span class="hljs-keyword">private</span> Long id;
    <span class="hljs-keyword">private</span> String name;
    <span class="hljs-function"><span class="hljs-keyword">public</span> Long <span class="hljs-title">getId</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.id;
    }
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setId</span><span class="hljs-params">(Long id)</span> </span>{
        <span class="hljs-keyword">this</span>.id = id;
    }
    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.name;
    }
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>{
        <span class="hljs-keyword">this</span>.name = name;
    }
    ...
}
</code></pre><p><strong>精简：</strong></p><pre class="highlight"><code class="java"><span class="hljs-meta">@Getter</span>
<span class="hljs-meta">@Setter</span>
<span class="hljs-meta">@ToString</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserVO</span> </span>{
    <span class="hljs-keyword">private</span> Long id;
    <span class="hljs-keyword">private</span> String name;
    ...
}
</code></pre><h3 id="22利用-validation-注解"><a class="markdownIt-Anchor" href="#22利用-validation-注解"></a> <strong>2.2.利用 Validation 注解</strong></h3><p><strong>普通：</strong></p><pre class="highlight"><code class="java"><span class="hljs-meta">@Getter</span><span class="hljs-meta">@Setter</span><span class="hljs-meta">@ToStringpublic</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserCreateVO</span> </span>{    
    <span class="hljs-meta">@NotBlank</span>(message = <span class="hljs-string">"用户名称不能为空"</span>)    
    <span class="hljs-keyword">private</span> String name;    
    <span class="hljs-meta">@NotNull</span>(message = <span class="hljs-string">"公司标识不能为空"</span>)    
    <span class="hljs-keyword">private</span> Long companyId;    
    ...
}

<span class="hljs-meta">@Service</span><span class="hljs-meta">@Validatedpublic</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserService</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> Long <span class="hljs-title">createUser</span><span class="hljs-params">(@Valid UserCreateVO create)</span> </span>{
        <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> 创建用户</span>
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
    }
}
</code></pre><p><strong>精简：</strong></p><pre class="highlight"><code class="java"><span class="hljs-meta">@Getter</span>
<span class="hljs-meta">@Setter</span>
<span class="hljs-meta">@ToString</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserCreateVO</span> </span>{
    <span class="hljs-meta">@NotBlank</span>(message = <span class="hljs-string">"用户名称不能为空"</span>)
    <span class="hljs-keyword">private</span> String name;
    <span class="hljs-meta">@NotNull</span>(message = <span class="hljs-string">"公司标识不能为空"</span>)
    <span class="hljs-keyword">private</span> Long companyId;
    ...
}

<span class="hljs-meta">@Service</span>
<span class="hljs-meta">@Validated</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserService</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> Long <span class="hljs-title">createUser</span><span class="hljs-params">(@Valid UserCreateVO create)</span> </span>{
        <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> 创建用户</span>
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
    }
}
</code></pre><h3 id="23利用-nonnull-注解"><a class="markdownIt-Anchor" href="#23利用-nonnull-注解"></a> <strong>2.3.利用 @NonNull 注解</strong></h3><p>Spring 的 @NonNull 注解，用于标注参数或返回值非空，适用于项目内部团队协作。只要实现方和调用方遵循规范，可以避免不必要的空值判断，这充分体现了阿里的“新六脉神剑”提倡的“因为信任，所以简单”。</p><p><strong>普通：</strong></p><pre class="highlight"><code class="java"><span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;UserVO&gt; <span class="hljs-title">queryCompanyUser</span><span class="hljs-params">(Long companyId)</span> </span>{
    <span class="hljs-comment">// 检查公司标识</span>
    <span class="hljs-keyword">if</span> (companyId == <span class="hljs-keyword">null</span>) {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
    }

    <span class="hljs-comment">// 查询返回用户</span>
    List&lt;UserDO&gt; userList = userDAO.queryByCompanyId(companyId);
    <span class="hljs-keyword">return</span> userList.stream().map(<span class="hljs-keyword">this</span>::transUser).collect(Collectors.toList());
}

Long companyId = <span class="hljs-number">1L</span>;
List&lt;UserVO&gt; userList = queryCompanyUser(companyId);
<span class="hljs-keyword">if</span> (CollectionUtils.isNotEmpty(userList)) {
    <span class="hljs-keyword">for</span> (UserVO user : userList) {
        <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> 处理公司用户</span>
    }
}
</code></pre><p><strong>精简：</strong></p><pre class="highlight"><code class="java"><span class="hljs-keyword">public</span> <span class="hljs-meta">@NonNull</span> <span class="hljs-function">List&lt;UserVO&gt; <span class="hljs-title">queryCompanyUser</span><span class="hljs-params">(@NonNull Long companyId)</span> </span>{
    List&lt;UserDO&gt; userList = userDAO.queryByCompanyId(companyId);
    <span class="hljs-keyword">return</span> userList.stream().map(<span class="hljs-keyword">this</span>::transUser).collect(Collectors.toList());
}

Long companyId = <span class="hljs-number">1L</span>;
List&lt;UserVO&gt; userList = queryCompanyUser(companyId);
<span class="hljs-keyword">for</span> (UserVO user : userList) {
    <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> 处理公司用户</span>
}
</code></pre><h3 id="24利用注解特性"><a class="markdownIt-Anchor" href="#24利用注解特性"></a> <strong>2.4.利用注解特性</strong></h3><p>注解有以下特性可用于精简注解声明：</p><p>1、当注解属性值跟默认值一致时，可以删除该属性赋值；</p><p>2、当注解只有value属性时，可以去掉value进行简写；</p><p>3、当注解属性组合等于另一个特定注解时，直接采用该特定注解。</p><p><strong>普通：</strong></p><pre class="highlight"><code class="java"><span class="hljs-meta">@Lazy</span>(<span class="hljs-keyword">true</span>);
<span class="hljs-meta">@Service</span>(value = <span class="hljs-string">"userService"</span>)
<span class="hljs-meta">@RequestMapping</span>(path = <span class="hljs-string">"/getUser"</span>, method = RequestMethod.GET)
</code></pre><p><strong>精简：</strong></p><pre class="highlight"><code class="java">java<span class="hljs-meta">@Lazy</span>
<span class="hljs-meta">@Service</span>(<span class="hljs-string">"userService"</span>)
<span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/getUser"</span>)
</code></pre><h2 id="利用泛型"><a class="markdownIt-Anchor" href="#利用泛型"></a> <strong>利用泛型</strong></h2><h3 id="31泛型接口"><a class="markdownIt-Anchor" href="#31泛型接口"></a> <strong>3.1.泛型接口</strong></h3><p>在 Java 没有引入泛型前，都是采用 Object 表示通用对象，最大的问题就是类型无法强校验并且需要强制类型转换。</p><p><strong>普通：</strong></p><pre class="highlight"><code class="java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Comparable</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compareTo</span><span class="hljs-params">(Object other)</span></span>;
}

<span class="hljs-meta">@Getter</span>
<span class="hljs-meta">@Setter</span>
<span class="hljs-meta">@ToString</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserVO</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Comparable</span> </span>{
    <span class="hljs-keyword">private</span> Long id;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compareTo</span><span class="hljs-params">(Object other)</span> </span>{
        UserVO user = (UserVO)other;
        <span class="hljs-keyword">return</span> Long.compare(<span class="hljs-keyword">this</span>.id, user.id);
    }
}
</code></pre><p><strong>精简：</strong></p><pre class="highlight"><code class="java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Comparable</span>&lt;<span class="hljs-title">T</span>&gt; </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compareTo</span><span class="hljs-params">(T other)</span></span>;
}

<span class="hljs-meta">@Getter</span>
<span class="hljs-meta">@Setter</span>
<span class="hljs-meta">@ToString</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserVO</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Comparable</span>&lt;<span class="hljs-title">UserVO</span>&gt; </span>{
    <span class="hljs-keyword">private</span> Long id;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compareTo</span><span class="hljs-params">(UserVO other)</span> </span>{
        <span class="hljs-keyword">return</span> Long.compare(<span class="hljs-keyword">this</span>.id, other.id);
    }
}
</code></pre><h3 id="32泛型类"><a class="markdownIt-Anchor" href="#32泛型类"></a> <strong>3.2.泛型类</strong></h3><p><strong>普通：</strong></p><pre class="highlight"><code class="java"><span class="hljs-meta">@Getter</span>
<span class="hljs-meta">@Setter</span>
<span class="hljs-meta">@ToString</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IntPoint</span> </span>{
    <span class="hljs-keyword">private</span> Integer x;
    <span class="hljs-keyword">private</span> Integer y;
}

<span class="hljs-meta">@Getter</span>
<span class="hljs-meta">@Setter</span>
<span class="hljs-meta">@ToString</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DoublePoint</span> </span>{
    <span class="hljs-keyword">private</span> Double x;
    <span class="hljs-keyword">private</span> Double y;
}
</code></pre><p><strong>精简：</strong></p><pre class="highlight"><code class="java"><span class="hljs-meta">@Getter</span>
<span class="hljs-meta">@Setter</span>
<span class="hljs-meta">@ToString</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Point</span>&lt;<span class="hljs-title">T</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Number</span>&gt; </span>{
    <span class="hljs-keyword">private</span> T x;
    <span class="hljs-keyword">private</span> T y;
}
</code></pre><h3 id="33泛型方法"><a class="markdownIt-Anchor" href="#33泛型方法"></a> <strong>3.3.泛型方法</strong></h3><p><strong>普通：</strong></p><pre class="highlight"><code class="java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Map&lt;String, Integer&gt; <span class="hljs-title">newHashMap</span><span class="hljs-params">(String[] keys, Integer[] values)</span> </span>{
    <span class="hljs-comment">// 检查参数非空</span>
    <span class="hljs-keyword">if</span> (ArrayUtils.isEmpty(keys) || ArrayUtils.isEmpty(values)) {
        <span class="hljs-keyword">return</span> Collections.emptyMap();
    }

    <span class="hljs-comment">// 转化哈希映射</span>
    Map&lt;String, Integer&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();
    <span class="hljs-keyword">int</span> length = Math.min(keys.length, values.length);
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; length; i++) {
        map.put(keys[i], values[i]);
    }
    <span class="hljs-keyword">return</span> map;
}
...
</code></pre><p><strong>精简：</strong></p><pre class="highlight"><code class="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;K, V&gt; <span class="hljs-function">Map&lt;K, V&gt; <span class="hljs-title">newHashMap</span><span class="hljs-params">(K[] keys, V[] values)</span> </span>{
    <span class="hljs-comment">// 检查参数非空</span>
    <span class="hljs-keyword">if</span> (ArrayUtils.isEmpty(keys) || ArrayUtils.isEmpty(values)) {
        <span class="hljs-keyword">return</span> Collections.emptyMap();
    }

    <span class="hljs-comment">// 转化哈希映射</span>
    Map&lt;K, V&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();
    <span class="hljs-keyword">int</span> length = Math.min(keys.length, values.length);
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; length; i++) {
        map.put(keys[i], values[i]);
    }
    <span class="hljs-keyword">return</span> map;
}
...
</code></pre><h2 id="利用自身方法"><a class="markdownIt-Anchor" href="#利用自身方法"></a> <strong>利用自身方法</strong></h2><h3 id="41利用构造方法"><a class="markdownIt-Anchor" href="#41利用构造方法"></a> <strong>4.1.利用构造方法</strong></h3><p>构造方法，可以简化对象的初始化和设置属性操作。对于属性字段较少的类，可以自定义构造方法。</p><p><strong>普通：</strong></p><pre class="highlight"><code class="java"><span class="hljs-meta">@Getter</span>
<span class="hljs-meta">@Setter</span>
<span class="hljs-meta">@ToString</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PageDataVO</span>&lt;<span class="hljs-title">T</span>&gt; </span>{
    <span class="hljs-keyword">private</span> Long totalCount;
    <span class="hljs-keyword">private</span> List&lt;T&gt; dataList;
}

PageDataVO&lt;UserVO&gt; pageData = <span class="hljs-keyword">new</span> PageDataVO&lt;&gt;();
pageData.setTotalCount(totalCount);
pageData.setDataList(userList);
<span class="hljs-keyword">return</span> pageData;
...
</code></pre><p><strong>精简：</strong></p><pre class="highlight"><code class="java"><span class="hljs-meta">@Getter</span>
<span class="hljs-meta">@Setter</span>
<span class="hljs-meta">@ToString</span>
<span class="hljs-meta">@NoArgsConstructor</span>
<span class="hljs-meta">@AllArgsConstructor</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PageDataVO</span>&lt;<span class="hljs-title">T</span>&gt; </span>{
    <span class="hljs-keyword">private</span> Long totalCount;
    <span class="hljs-keyword">private</span> List&lt;T&gt; dataList;
}

<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> PageDataVO&lt;&gt;(totalCount, userList);
</code></pre><p>注意：如果属性字段被替换时，存在构造函数初始化赋值问题。比如把属性字段title替换为 nickname ，由于构造函数的参数个数和类型不变，原有构造函数初始化语句不会报错，导致把原title值赋值给 nickname 。如果采用 Setter 方法赋值，编译器会提示错误并要求修复。</p><h3 id="42利用-set-的-add-方法"><a class="markdownIt-Anchor" href="#42利用-set-的-add-方法"></a> <strong>4.2.利用 Set 的 add 方法</strong></h3><p>利用 Set 的 add 方法的返回值，可以直接知道该值是否已经存在，可以避免调用 contains 方法判断存在。</p><p><strong>普通：</strong></p><p>以下案例是进行用户去重转化操作，需要先调用 contains 方法判断存在，后调用add方法进行添加。</p><pre class="highlight"><code class="java">Set&lt;Long&gt; userIdSet = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();
List&lt;UserVO&gt; userVOList = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();
<span class="hljs-keyword">for</span> (UserDO userDO : userDOList) {
    <span class="hljs-keyword">if</span> (!userIdSet.contains(userDO.getId())) {
        userIdSet.add(userDO.getId());
        userVOList.add(transUser(userDO));
    }
}
</code></pre><p><strong>精简：</strong></p><pre class="highlight"><code class="java">Set&lt;Long&gt; userIdSet = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();
List&lt;UserVO&gt; userVOList = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();
<span class="hljs-keyword">for</span> (UserDO userDO : userDOList) {
    <span class="hljs-keyword">if</span> (userIdSet.add(userDO.getId())) {
        userVOList.add(transUser(userDO));
    }
}
</code></pre><h3 id="43利用-map-的-computeifabsent-方法"><a class="markdownIt-Anchor" href="#43利用-map-的-computeifabsent-方法"></a> <strong>4.3.利用 Map 的 computeIfAbsent 方法</strong></h3><p>利用 Map 的 computeIfAbsent 方法，可以保证获取到的对象非空，从而避免了不必要的空判断和重新设置值。</p><p><strong>普通：</strong></p><pre class="highlight"><code class="java">Map&lt;Long, List&lt;UserDO&gt;&gt; roleUserMap = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();
<span class="hljs-keyword">for</span> (UserDO userDO : userDOList) {
    Long roleId = userDO.getRoleId();
    List&lt;UserDO&gt; userList = roleUserMap.get(roleId);
    <span class="hljs-keyword">if</span> (Objects.isNull(userList)) {
        userList = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();
        roleUserMap.put(roleId, userList);
    }
    userList.add(userDO);
}
</code></pre><p><strong>精简：</strong></p><pre class="highlight"><code class="java">Map&lt;Long, List&lt;UserDO&gt;&gt; roleUserMap = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();
<span class="hljs-keyword">for</span> (UserDO userDO : userDOList) {
    roleUserMap.computeIfAbsent(userDO.getRoleId(), key -&gt; <span class="hljs-keyword">new</span> ArrayList&lt;&gt;())
        .add(userDO);
}
</code></pre><h3 id="44利用链式编程"><a class="markdownIt-Anchor" href="#44利用链式编程"></a> <strong>4.4.利用链式编程</strong></h3><p>链式编程，也叫级联式编程，调用对象的函数时返回一个this对象指向对象本身，达到链式效果，可以级联调用。链式编程的优点是：编程性强、可读性强、代码简洁。</p><p><strong>普通：</strong></p><pre class="highlight"><code class="java">StringBuilder builder = <span class="hljs-keyword">new</span> StringBuilder(<span class="hljs-number">96</span>);
builder.append(<span class="hljs-string">"select id, name from "</span>);
builder.append(T_USER);
builder.append(<span class="hljs-string">" where id = "</span>);
builder.append(userId);
builder.append(<span class="hljs-string">";"</span>);
</code></pre><p><strong>精简：</strong></p><pre class="highlight"><code class="java">StringBuilder builder = <span class="hljs-keyword">new</span> StringBuilder(<span class="hljs-number">96</span>);
builder.append(<span class="hljs-string">"select id, name from "</span>)
    .append(T_USER)
    .append(<span class="hljs-string">" where id = "</span>)
    .append(userId)
    .append(<span class="hljs-string">";"</span>);
</code></pre><h2 id="利用工具方法"><a class="markdownIt-Anchor" href="#利用工具方法"></a> <strong>利用工具方法</strong></h2><h3 id="51避免空值判断"><a class="markdownIt-Anchor" href="#51避免空值判断"></a> <strong>5.1.避免空值判断</strong></h3><p><strong>普通：</strong></p><pre class="highlight"><code class="java"><span class="hljs-keyword">if</span> (userList != <span class="hljs-keyword">null</span> &amp;&amp; !userList.isEmpty()) {
    <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> 处理代码</span>
}
</code></pre><p><strong>精简：</strong></p><pre class="highlight"><code class="java"><span class="hljs-keyword">if</span> (CollectionUtils.isNotEmpty(userList)) {
    <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> 处理代码java</span>
}
</code></pre><h3 id="52避免条件判断"><a class="markdownIt-Anchor" href="#52避免条件判断"></a> <strong>5.2.避免条件判断</strong></h3><p><strong>普通：</strong></p><pre class="highlight"><code class="java"><span class="hljs-keyword">double</span> result;
<span class="hljs-keyword">if</span> (value &lt;= MIN_LIMIT) {
    result = MIN_LIMIT;
} <span class="hljs-keyword">else</span> {
    result = value;
}
</code></pre><p><strong>精简：</strong></p><pre class="highlight"><code class="java"><span class="hljs-keyword">double</span> result = Math.max(MIN_LIMIT, value);
</code></pre><h3 id="53简化赋值语句"><a class="markdownIt-Anchor" href="#53简化赋值语句"></a> <strong>5.3.简化赋值语句</strong></h3><p><strong>普通：</strong></p><pre class="highlight"><code class="java">javapublic <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> List&lt;String&gt; ANIMAL_LIST;
<span class="hljs-keyword">static</span> {
    List&lt;String&gt; animalList = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();
    animalList.add(<span class="hljs-string">"dog"</span>);
    animalList.add(<span class="hljs-string">"cat"</span>);
    animalList.add(<span class="hljs-string">"tiger"</span>);
    ANIMAL_LIST = Collections.unmodifiableList(animalList);
}
</code></pre><p><strong>精简：</strong></p><pre class="highlight"><code class="java"><span class="hljs-comment">// JDK流派</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> List&lt;String&gt; ANIMAL_LIST = Arrays.asList(<span class="hljs-string">"dog"</span>, <span class="hljs-string">"cat"</span>, <span class="hljs-string">"tiger"</span>);
<span class="hljs-comment">// Guava流派</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> List&lt;String&gt; ANIMAL_LIST = ImmutableList.of(<span class="hljs-string">"dog"</span>, <span class="hljs-string">"cat"</span>, <span class="hljs-string">"tiger"</span>);
</code></pre><p>注意：Arrays.asList 返回的 List 并不是 ArrayList ，不支持 add 等变更操作。</p><h3 id="54简化数据拷贝"><a class="markdownIt-Anchor" href="#54简化数据拷贝"></a> <strong>5.4.简化数据拷贝</strong></h3><p><strong>普通：</strong></p><pre class="highlight"><code class="java">UserVO userVO = <span class="hljs-keyword">new</span> UserVO();
userVO.setId(userDO.getId());
userVO.setName(userDO.getName());
...
userVO.setDescription(userDO.getDescription());
userVOList.add(userVO);
</code></pre><p><strong>精简：</strong></p><pre class="highlight"><code class="java">UserVO userVO = <span class="hljs-keyword">new</span> UserVO();
BeanUtils.copyProperties(userDO, userVO);
userVOList.add(userVO);
</code></pre><p><strong>反例：</strong></p><pre class="highlight"><code class="java">List&lt;UserVO&gt; userVOList = JSON.parseArray(JSON.toJSONString(userDOList), UserVO<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;
</code></pre><p>精简代码，但不能以过大的性能损失为代价。例子是浅层拷贝，用不着 JSON 这样重量级的武器。</p><h3 id="55简化异常断言"><a class="markdownIt-Anchor" href="#55简化异常断言"></a> 5.5.简化异常断言</h3><p><strong>普通：</strong></p><pre class="highlight"><code class="java"><span class="hljs-keyword">if</span> (Objects.isNull(userId)) {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">"用户标识不能为空"</span>);
}
</code></pre><p><strong>精简：</strong></p><pre class="highlight"><code class="java">Assert.notNull(userId, <span class="hljs-string">"用户标识不能为空"</span>);
</code></pre><p>注意：可能有些插件不认同这种判断，导致使用该对象时会有空指针警告。</p><h3 id="56简化测试用例"><a class="markdownIt-Anchor" href="#56简化测试用例"></a> <strong>5.6.简化测试用例</strong></h3><p>把测试用例数据以 JSON 格式存入文件中，通过 JSON 的 parseObject 和 parseArray 方法解析成对象。虽然执行效率上有所下降，但可以减少大量的赋值语句，从而精简了测试代码。</p><p><strong>普通：</strong></p><pre class="highlight"><code class="java"><span class="hljs-meta">@Test</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testCreateUser</span><span class="hljs-params">()</span> </span>{
    UserCreateVO userCreate = <span class="hljs-keyword">new</span> UserCreateVO();
    userCreate.setName(<span class="hljs-string">"Changyi"</span>);
    userCreate.setTitle(<span class="hljs-string">"Developer"</span>);
    userCreate.setCompany(<span class="hljs-string">"AMAP"</span>);
    ...
    Long userId  = userService.createUser(OPERATOR, userCreate);
    Assert.assertNotNull(userId, <span class="hljs-string">"创建用户失败"</span>);
}
</code></pre><p><strong>精简：</strong></p><pre class="highlight"><code class="java"><span class="hljs-meta">@Test</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testCreateUser</span><span class="hljs-params">()</span> </span>{
    String jsonText = ResourceHelper.getResourceAsString(getClass(), <span class="hljs-string">"createUser.json"</span>);
    UserCreateVO userCreate = JSON.parseObject(jsonText, UserCreateVO<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;
    Long userId  = userService.createUser(OPERATOR, userCreate);
    Assert.assertNotNull(userId, <span class="hljs-string">"创建用户失败"</span>);
}
</code></pre><p>建议：JSON 文件名最好以被测试的方法命名，如果有多个版本可以用数字后缀表示。</p><h3 id="57简化算法实现"><a class="markdownIt-Anchor" href="#57简化算法实现"></a> <strong>5.7.简化算法实现</strong></h3><p>一些常规算法，已有现成的工具方法，我们就没有必要自己实现了。</p><p><strong>普通：</strong></p><pre class="highlight"><code class="java"><span class="hljs-keyword">int</span> totalSize = valueList.size();
List&lt;List&lt;Integer&gt;&gt; partitionList = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; totalSize; i += PARTITION_SIZE) {
    partitionList.add(valueList.subList(i, Math.min(i + PARTITION_SIZE, totalSize)));
}
</code></pre><p><strong>精简：</strong></p><pre class="highlight"><code class="java">List&lt;List&lt;Integer&gt;&gt; partitionList = ListUtils.partition(valueList, PARTITION_SIZE);
<span class="hljs-number">5.8</span>.封装工具方法
</code></pre><p>一些特殊算法，没有现成的工具方法，我们就只好自己亲自实现了。</p><p><strong>普通：</strong></p><p>比如，SQL 设置参数值的方法就比较难用，setLong 方法不能设置参数值为 null 。</p><pre class="highlight"><code class="java"> <span class="hljs-comment">// 设置参数值</span>
<span class="hljs-keyword">if</span> (Objects.nonNull(user.getId())) {
  statement.setLong(<span class="hljs-number">1</span>, user.getId());
} <span class="hljs-keyword">else</span> {
    statement.setNull(<span class="hljs-number">1</span>, Types.BIGINT);
}
...
</code></pre><p><strong>精简：</strong></p><p>我们可以封装为一个工具类 SqlHelper ，简化设置参数值的代码。</p><pre class="highlight"><code class="java"><span class="hljs-comment">/** SQL辅助类 */</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SqlHelper</span> </span>{
    <span class="hljs-comment">/** 设置长整数值 */</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setLong</span><span class="hljs-params">(PreparedStatement statement, <span class="hljs-keyword">int</span> index, Long value)</span> <span class="hljs-keyword">throws</span> SQLException </span>{
        <span class="hljs-keyword">if</span> (Objects.nonNull(value)) {
            statement.setLong(index, value.longValue());
        } <span class="hljs-keyword">else</span> {
            statement.setNull(index, Types.BIGINT);
        }
    }
    ...
}

 <span class="hljs-comment">// 设置参数值</span>
SqlHelper.setLong(statement, <span class="hljs-number">1</span>, user.getId());
</code></pre><h2 id="利用数据结构"><a class="markdownIt-Anchor" href="#利用数据结构"></a> <strong>利用数据结构</strong></h2><h3 id="61利用数组简化"><a class="markdownIt-Anchor" href="#61利用数组简化"></a> <strong>6.1.利用数组简化</strong></h3><p>对于固定上下限范围的 if-else 语句，可以用数组+循环来简化。</p><p><strong>普通：</strong></p><pre class="highlight"><code class="java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getGrade</span><span class="hljs-params">(<span class="hljs-keyword">double</span> score)</span> </span>{
    <span class="hljs-keyword">if</span> (score &gt;= <span class="hljs-number">90.0</span>D) {
        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
    }
    <span class="hljs-keyword">if</span> (score &gt;= <span class="hljs-number">80.0</span>D) {
        <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;
    }
    <span class="hljs-keyword">if</span> (score &gt;= <span class="hljs-number">60.0</span>D) {
        <span class="hljs-keyword">return</span> <span class="hljs-number">3</span>;
    }
    <span class="hljs-keyword">if</span> (score &gt;= <span class="hljs-number">30.0</span>D) {
        <span class="hljs-keyword">return</span> <span class="hljs-number">4</span>;
    }
    <span class="hljs-keyword">return</span> <span class="hljs-number">5</span>;
}
</code></pre><p><strong>精简：</strong></p><pre class="highlight"><code class="java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">double</span>[] SCORE_RANGES = <span class="hljs-keyword">new</span> <span class="hljs-keyword">double</span>[] {<span class="hljs-number">90.0</span>D, <span class="hljs-number">80.0</span>D, <span class="hljs-number">60.0</span>D, <span class="hljs-number">30.0</span>D};
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getGrade</span><span class="hljs-params">(<span class="hljs-keyword">double</span> score)</span> </span>{
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; SCORE_RANGES.length; i++) {
        <span class="hljs-keyword">if</span> (score &gt;= SCORE_RANGES[i]) {
            <span class="hljs-keyword">return</span> i + <span class="hljs-number">1</span>;
        }
    }
    <span class="hljs-keyword">return</span> SCORE_RANGES.length + <span class="hljs-number">1</span>;
}
</code></pre><p>思考：上面的案例返回值是递增的，所以用数组简化是没有问题的。但是，如果返回值不是递增的，能否用数组进行简化呢？答案是可以的，请自行思考解决。</p><h3 id="62利用-map-简化"><a class="markdownIt-Anchor" href="#62利用-map-简化"></a> <strong>6.2.利用 Map 简化</strong></h3><p>对于映射关系的 if-else 语句，可以用Map来简化。此外，此规则同样适用于简化映射关系的 switch 语句。</p><p><strong>普通：</strong></p><pre class="highlight"><code class="java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">getBiologyClass</span><span class="hljs-params">(String name)</span> </span>{
    <span class="hljs-keyword">switch</span> (name) {
        <span class="hljs-keyword">case</span> <span class="hljs-string">"dog"</span> :
            <span class="hljs-keyword">return</span> <span class="hljs-string">"animal"</span>;
        <span class="hljs-keyword">case</span> <span class="hljs-string">"cat"</span> :
            <span class="hljs-keyword">return</span> <span class="hljs-string">"animal"</span>;
        <span class="hljs-keyword">case</span> <span class="hljs-string">"lavender"</span> :
            <span class="hljs-keyword">return</span> <span class="hljs-string">"plant"</span>;
        ...
        <span class="hljs-keyword">default</span> :
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
    }
}
</code></pre><p><strong>精简：</strong></p><pre class="highlight"><code class="java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Map&lt;String, String&gt; BIOLOGY_CLASS_MAP
    = ImmutableMap.&lt;String, String&gt;builder()
        .put(<span class="hljs-string">"dog"</span>, <span class="hljs-string">"animal"</span>)
        .put(<span class="hljs-string">"cat"</span>, <span class="hljs-string">"animal"</span>)
        .put(<span class="hljs-string">"lavender"</span>, <span class="hljs-string">"plant"</span>)
        ...
        .build();
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">getBiologyClass</span><span class="hljs-params">(String name)</span> </span>{
    <span class="hljs-keyword">return</span> BIOLOGY_CLASS_MAP.get(name);
}
</code></pre><p>已经把方法简化为一行代码，其实都没有封装方法的必要了。</p><h3 id="63利用容器类简化"><a class="markdownIt-Anchor" href="#63利用容器类简化"></a> <strong>6.3.利用容器类简化</strong></h3><p>Java 不像 Python 和 Go ，方法不支持返回多个对象。如果需要返回多个对象，就必须自定义类，或者利用容器类。常见的容器类有 Apache 的 Pair 类和 Triple 类， Pair 类支持返回 2 个对象， Triple 类支持返回 3 个对象。</p><p><strong>普通：</strong></p><pre class="highlight"><code class="java"><span class="hljs-meta">@Setter</span>
<span class="hljs-meta">@Getter</span>
<span class="hljs-meta">@ToString</span>
<span class="hljs-meta">@AllArgsConstructor</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PointAndDistance</span> </span>{
    <span class="hljs-keyword">private</span> Point point;
    <span class="hljs-keyword">private</span> Double distance;
}

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> PointAndDistance <span class="hljs-title">getNearest</span><span class="hljs-params">(Point point, Point[] points)</span> </span>{
    <span class="hljs-comment">// 计算最近点和距离</span>
    ...

    <span class="hljs-comment">// 返回最近点和距离</span>
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> PointAndDistance(nearestPoint, nearestDistance);
}
</code></pre><p><strong>精简：</strong></p><pre class="highlight"><code class="java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Pair&lt;Point, Double&gt; <span class="hljs-title">getNearest</span><span class="hljs-params">(Point point, Point[] points)</span> </span>{
    <span class="hljs-comment">// 计算最近点和距离</span>
    ...

    <span class="hljs-comment">// 返回最近点和距离</span>
    <span class="hljs-keyword">return</span> ImmutablePair.of(nearestPoint, nearestDistance);
}
</code></pre><h3 id="64利用-threadlocal-简化"><a class="markdownIt-Anchor" href="#64利用-threadlocal-简化"></a> <strong>6.4.利用 ThreadLocal 简化</strong></h3><p>ThreadLocal 提供了线程专有对象，可以在整个线程生命周期中随时取用，极大地方便了一些逻辑的实现。用 ThreadLocal 保存线程上下文对象，可以避免不必要的参数传递。</p><p><strong>普通：</strong></p><p>由于 DateFormat 的 format 方法线程非安全（建议使用替代方法），在线程中频繁初始化 DateFormat 性能太低，如果考虑重用只能用参数传入 DateFormat 。例子如下：</p><pre class="highlight"><code class="java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">formatDate</span><span class="hljs-params">(Date date, DateFormat format)</span> </span>{
    <span class="hljs-keyword">return</span> format.format(date);
}

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> List&lt;String&gt; <span class="hljs-title">getDateList</span><span class="hljs-params">(Date minDate, Date maxDate, DateFormat format)</span> </span>{
    List&lt;String&gt; dateList = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();
    Calendar calendar = Calendar.getInstance();
    calendar.setTime(minDate);
    String currDate = formatDate(calendar.getTime(), format);
    String maxsDate = formatDate(maxDate, format);
    <span class="hljs-keyword">while</span> (currDate.compareTo(maxsDate) &lt;= <span class="hljs-number">0</span>) {
        dateList.add(currDate);
        calendar.add(Calendar.DATE, <span class="hljs-number">1</span>);
        currDate = formatDate(calendar.getTime(), format);
    }
    <span class="hljs-keyword">return</span> dateList;
}
精简：
</code></pre><p>可能你会觉得以下的代码量反而多了，如果调用工具方法的地方比较多，就可以省下一大堆 DateFormat 初始化和传入参数的代码。</p><pre class="highlight"><code class="java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> ThreadLocal&lt;DateFormat&gt; LOCAL_DATE_FORMAT = <span class="hljs-keyword">new</span> ThreadLocal&lt;DateFormat&gt;() {
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">protected</span> DateFormat <span class="hljs-title">initialValue</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> SimpleDateFormat(<span class="hljs-string">"yyyyMMdd"</span>);
    }
};

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">formatDate</span><span class="hljs-params">(Date date)</span> </span>{
    <span class="hljs-keyword">return</span> LOCAL_DATE_FORMAT.get().format(date);
}

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> List&lt;String&gt; <span class="hljs-title">getDateList</span><span class="hljs-params">(Date minDate, Date maxDate)</span> </span>{
    List&lt;String&gt; dateList = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();
    Calendar calendar = Calendar.getInstance();
    calendar.setTime(minDate);
    String currDate = formatDate(calendar.getTime());
    String maxsDate = formatDate(maxDate);
    <span class="hljs-keyword">while</span> (currDate.compareTo(maxsDate) &lt;= <span class="hljs-number">0</span>) {
        dateList.add(currDate);
        calendar.add(Calendar.DATE, <span class="hljs-number">1</span>);
        currDate = formatDate(calendar.getTime());
    }
    <span class="hljs-keyword">return</span> dateList;
}
</code></pre><p>注意：ThreadLocal 有一定的内存泄露的风险，尽量在业务代码结束前调用 remove 方法进行数据清除。</p><h2 id="利用-optional"><a class="markdownIt-Anchor" href="#利用-optional"></a> <strong>利用 Optional</strong></h2><p>在 Java 8 里，引入了一个 Optional 类，该类是一个可以为 null 的容器对象。</p><h3 id="71保证值存在"><a class="markdownIt-Anchor" href="#71保证值存在"></a> <strong>7.1.保证值存在</strong></h3><p><strong>普通：</strong></p><pre class="highlight"><code class="java">Integer thisValue;
<span class="hljs-keyword">if</span> (Objects.nonNull(value)) {
    thisValue = value;
} <span class="hljs-keyword">else</span> {
    thisValue = DEFAULT_VALUE;
}
</code></pre><p><strong>精简：</strong></p><pre class="highlight"><code class="java">Integer thisValue = Optional.ofNullable(value).orElse(DEFAULT_VALUE);
</code></pre><h3 id="72保证值合法"><a class="markdownIt-Anchor" href="#72保证值合法"></a> <strong>7.2.保证值合法</strong></h3><p><strong>普通：</strong></p><pre class="highlight"><code class="java">Integer thisValue;
<span class="hljs-keyword">if</span> (Objects.nonNull(value) &amp;&amp; value.compareTo(MAX_VALUE) &lt;= <span class="hljs-number">0</span>) {
    thisValue = value;
} <span class="hljs-keyword">else</span> {
    thisValue = MAX_VALUE;
}
精简：
Integer thisValue = Optional.ofNullable(value)
    .filter(tempValue -&gt; tempValue.compareTo(MAX_VALUE) &lt;= <span class="hljs-number">0</span>).orElse(MAX_VALUE);
<span class="hljs-number">7.3</span>.避免空判断
</code></pre><p><strong>普通：</strong></p><pre class="highlight"><code class="java">String zipcode = <span class="hljs-keyword">null</span>;
<span class="hljs-keyword">if</span> (Objects.nonNull(user)) {
    Address address = user.getAddress();
    <span class="hljs-keyword">if</span> (Objects.nonNull(address)) {
        Country country = address.getCountry();
        <span class="hljs-keyword">if</span> (Objects.nonNull(country)) {
            zipcode = country.getZipcode();
        }
    }
}
精简：
String zipcode = Optional.ofNullable(user).map(User::getAddress)
    .map(Address::getCountry).map(Country::getZipcode).orElse(<span class="hljs-keyword">null</span>);
</code></pre><h2 id="利用-stream"><a class="markdownIt-Anchor" href="#利用-stream"></a> <strong>利用 Stream</strong></h2><p>流（Stream）是Java 8的新成员，允许你以声明式处理数据集合，可以看成为一个遍历数据集的高级迭代器。流主要有三部分构成：获取一个数据源→数据转换→执行操作获取想要的结果。每次转换原有 Stream 对象不改变，返回一个新的 Stream 对象，这就允许对其操作可以像链条一样排列，形成了一个管道。流（Stream）提供的功能非常有用，主要包括匹配、过滤、汇总、转化、分组、分组汇总等功能。</p><h3 id="81匹配集合数据"><a class="markdownIt-Anchor" href="#81匹配集合数据"></a> <strong>8.1.匹配集合数据</strong></h3><p><strong>普通：</strong></p><pre class="highlight"><code class="java"><span class="hljs-keyword">boolean</span> isFound = <span class="hljs-keyword">false</span>;
<span class="hljs-keyword">for</span> (UserDO user : userList) {
    <span class="hljs-keyword">if</span> (Objects.equals(user.getId(), userId)) {
        isFound = <span class="hljs-keyword">true</span>;
        <span class="hljs-keyword">break</span>;
    }
}
</code></pre><p><strong>精简：</strong></p><pre class="highlight"><code class="java"><span class="hljs-keyword">boolean</span> isFound = userList.stream()
    .anyMatch(user -&gt; Objects.equals(user.getId(), userId));
</code></pre><h3 id="82过滤集合数据"><a class="markdownIt-Anchor" href="#82过滤集合数据"></a> 8.2.过滤集合数据</h3><p>普通：**</p><pre class="highlight"><code class="java">List&lt;UserDO&gt; resultList = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();
<span class="hljs-keyword">for</span> (UserDO user : userList) {
    <span class="hljs-keyword">if</span> (Boolean.TRUE.equals(user.getIsSuper())) {
        resultList.add(user);
    }
}
</code></pre><p><strong>精简：</strong></p><pre class="highlight"><code class="java">List&lt;UserDO&gt; resultList = userList.stream()
    .filter(user -&gt; Boolean.TRUE.equals(user.getIsSuper()))
    .collect(Collectors.toList());

</code></pre><h3 id="83汇总集合数据"><a class="markdownIt-Anchor" href="#83汇总集合数据"></a> 8.3.汇总集合数据</h3><p><strong>普通：</strong></p><pre class="highlight"><code class="java"><span class="hljs-keyword">double</span> total = <span class="hljs-number">0.0</span>D;
<span class="hljs-keyword">for</span> (Account account : accountList) {
    total += account.getBalance();
}
</code></pre><p><strong>精简：</strong></p><pre class="highlight"><code class="java"><span class="hljs-keyword">double</span> total = accountList.stream().mapToDouble(Account::getBalance).sum();
</code></pre><h3 id="84转化集合数据"><a class="markdownIt-Anchor" href="#84转化集合数据"></a> 8.4.转化集合数据</h3><p>普通：**</p><pre class="highlight"><code class="java">List&lt;UserVO&gt; userVOList = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();
<span class="hljs-keyword">for</span> (UserDO userDO : userDOList) {
    userVOList.add(transUser(userDO));
}
</code></pre><p><strong>精简：</strong></p><pre class="highlight"><code class="java">List&lt;UserVO&gt; userVOList = userDOList.stream()
    .map(<span class="hljs-keyword">this</span>::transUser).collect(Collectors.toList());
</code></pre><h3 id="85分组集合数据"><a class="markdownIt-Anchor" href="#85分组集合数据"></a> <strong>8.5.分组集合数据</strong></h3><p><strong>普通：</strong></p><pre class="highlight"><code class="java">Map&lt;Long, List&lt;UserDO&gt;&gt; roleUserMap = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();
<span class="hljs-keyword">for</span> (UserDO userDO : userDOList) {
    roleUserMap.computeIfAbsent(userDO.getRoleId(), key -&gt; <span class="hljs-keyword">new</span> ArrayList&lt;&gt;())
        .add(userDO);
}
</code></pre><p><strong>精简：</strong></p><pre class="highlight"><code class="java">Map&lt;Long, List&lt;UserDO&gt;&gt; roleUserMap = userDOList.stream()
    .collect(Collectors.groupingBy(UserDO::getRoleId));
</code></pre><h3 id="86分组汇总集合"><a class="markdownIt-Anchor" href="#86分组汇总集合"></a> 8.6.分组汇总集合</h3><p>普通：**</p><pre class="highlight"><code class="java">Map&lt;Long, Double&gt; roleTotalMap = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();
<span class="hljs-keyword">for</span> (Account account : accountList) {
    Long roleId = account.getRoleId();
    Double total = Optional.ofNullable(roleTotalMap.get(roleId)).orElse(<span class="hljs-number">0.0</span>D);
    roleTotalMap.put(roleId, total + account.getBalance());
}
</code></pre><p><strong>精简：</strong></p><pre class="highlight"><code class="java">roleTotalMap = accountList.stream().collect(Collectors.groupingBy(Account::getRoleId, Collectors.summingDouble(Account::getBalance)));
</code></pre><h3 id="87生成范围集合"><a class="markdownIt-Anchor" href="#87生成范围集合"></a> 8.7.生成范围集合</h3><p>Python 的 range 非常方便，Stream 也提供了类似的方法。</p><p><strong>普通：</strong></p><pre class="highlight"><code class="java"><span class="hljs-keyword">int</span>[] array1 = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[N];
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; N; i++) {
    array1[i] = i + <span class="hljs-number">1</span>;
}

<span class="hljs-keyword">int</span>[] array2 = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[N];
array2[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; N; i++) {
    array2[i] = array2[i - <span class="hljs-number">1</span>] * <span class="hljs-number">2</span>;
}
</code></pre><p><strong>精简：</strong></p><pre class="highlight"><code class="java"><span class="hljs-keyword">int</span>[] array1 = IntStream.rangeClosed(<span class="hljs-number">1</span>, N).toArray();
<span class="hljs-keyword">int</span>[] array2 = IntStream.iterate(<span class="hljs-number">1</span>, n -&gt; n * <span class="hljs-number">2</span>).limit(N).toArray();
</code></pre><h2 id="利用程序结构"><a class="markdownIt-Anchor" href="#利用程序结构"></a> <strong>利用程序结构</strong></h2><h3 id="91返回条件表达式"><a class="markdownIt-Anchor" href="#91返回条件表达式"></a> <strong>9.1.返回条件表达式</strong></h3><p>条件表达式判断返回布尔值，条件表达式本身就是结果。</p><p><strong>普通：</strong></p><pre class="highlight"><code class="java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isSuper</span><span class="hljs-params">(Long userId)</span>
    UserDO user </span>= userDAO.get(userId);
    <span class="hljs-keyword">if</span> (Objects.nonNull(user) &amp;&amp; Boolean.TRUE.equals(user.getIsSuper())) {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
    }
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
}
</code></pre><p><strong>精简：</strong></p><pre class="highlight"><code class="java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isSuper</span><span class="hljs-params">(Long userId)</span>
    UserDO user </span>= userDAO.get(userId);
    <span class="hljs-keyword">return</span> Objects.nonNull(user) &amp;&amp; Boolean.TRUE.equals(user.getIsSuper());
}
</code></pre><h3 id="92最小化条件作用域"><a class="markdownIt-Anchor" href="#92最小化条件作用域"></a> 9.2.最小化条件作用域</h3><p>最小化条件作用域，尽量提出公共处理代码。</p><p><strong>普通：</strong></p><pre class="highlight"><code class="java">Result result = summaryService.reportWorkDaily(workDaily);
<span class="hljs-keyword">if</span> (result.isSuccess()) {
    String message = <span class="hljs-string">"上报工作日报成功"</span>;
    dingtalkService.sendMessage(user.getPhone(), message);
} <span class="hljs-keyword">else</span> {
    String message = <span class="hljs-string">"上报工作日报失败:"</span> + result.getMessage();
    log.warn(message);
    dingtalkService.sendMessage(user.getPhone(), message);
}
</code></pre><p><strong>精简：</strong></p><pre class="highlight"><code class="java">String message;
Result result = summaryService.reportWorkDaily(workDaily);
<span class="hljs-keyword">if</span> (result.isSuccess()) {
    message = <span class="hljs-string">"上报工作日报成功"</span>;
} <span class="hljs-keyword">else</span> {
    message = <span class="hljs-string">"上报工作日报失败:"</span> + result.getMessage();
    log.warn(message);
}
dingtalkService.sendMessage(user.getPhone(), message);
</code></pre><h3 id="93调整表达式位置"><a class="markdownIt-Anchor" href="#93调整表达式位置"></a> <strong>9.3.调整表达式位置</strong></h3><p>调整表达式位置，在逻辑不变的前提下，让代码变得更简洁。</p><p><strong>普通1：</strong></p><pre class="highlight"><code class="java">String line = readLine();
<span class="hljs-keyword">while</span> (Objects.nonNull(line)) {
    ... <span class="hljs-comment">// 处理逻辑代码</span>
    line = readLine();
}
</code></pre><p><strong>普通2：</strong></p><pre class="highlight"><code class="java"><span class="hljs-keyword">for</span> (String line = readLine(); Objects.nonNull(line); line = readLine()) {
    ... <span class="hljs-comment">// 处理逻辑代码</span>
}
精简：
String line;
<span class="hljs-keyword">while</span> (Objects.nonNull(line = readLine())) {
    ... <span class="hljs-comment">// 处理逻辑代码</span>
}
</code></pre><p>注意：有些规范可能不建议这种精简写法。</p><h3 id="94利用非空对象"><a class="markdownIt-Anchor" href="#94利用非空对象"></a> <strong>9.4.利用非空对象</strong></h3><p>在比较对象时，交换对象位置，利用非空对象，可以避免空指针判断。</p><p><strong>普通：</strong></p><pre class="highlight"><code class="java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> MAX_VALUE = <span class="hljs-number">1000</span>;
<span class="hljs-keyword">boolean</span> isMax = (value != <span class="hljs-keyword">null</span> &amp;&amp; value.equals(MAX_VALUE));
<span class="hljs-keyword">boolean</span> isTrue = (result != <span class="hljs-keyword">null</span> &amp;&amp; result.equals(Boolean.TRUE));
</code></pre><p><strong>精简：</strong></p><pre class="highlight"><code class="java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Integer MAX_VALUE = <span class="hljs-number">1000</span>;
<span class="hljs-keyword">boolean</span> isMax = MAX_VALUE.equals(value);
<span class="hljs-keyword">boolean</span> isTrue = Boolean.TRUE.equals(result);
</code></pre><h2 id="利用设计模式"><a class="markdownIt-Anchor" href="#利用设计模式"></a> <strong>利用设计模式</strong></h2><h3 id="101模板方法模式"><a class="markdownIt-Anchor" href="#101模板方法模式"></a> <strong>10.1.模板方法模式</strong></h3><p>模板方法模式（Template Method Pattern）定义一个固定的算法框架，而将算法的一些步骤放到子类中实现，使得子类可以在不改变算法框架的情况下重定义该算法的某些步骤。</p><p><strong>普通：</strong></p><pre class="highlight"><code class="java"><span class="hljs-meta">@Repository</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserValue</span> </span>{
    <span class="hljs-comment">/** 值操作 */</span>
    <span class="hljs-meta">@Resource</span>(name = <span class="hljs-string">"stringRedisTemplate"</span>)
    <span class="hljs-keyword">private</span> ValueOperations&lt;String, String&gt; valueOperations;
    <span class="hljs-comment">/** 值模式 */</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String KEY_FORMAT = <span class="hljs-string">"Value:User:%s"</span>;

    <span class="hljs-comment">/** 设置值 */</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">set</span><span class="hljs-params">(Long id, UserDO value)</span> </span>{
        String key = String.format(KEY_FORMAT, id);
        valueOperations.set(key, JSON.toJSONString(value));
    }

    <span class="hljs-comment">/** 获取值 */</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> UserDO <span class="hljs-title">get</span><span class="hljs-params">(Long id)</span> </span>{
        String key = String.format(KEY_FORMAT, id);
        String value = valueOperations.get(key);
        <span class="hljs-keyword">return</span> JSON.parseObject(value, UserDO<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;
    }

    ...
}

<span class="hljs-meta">@Repository</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RoleValue</span> </span>{
    <span class="hljs-comment">/** 值操作 */</span>
    <span class="hljs-meta">@Resource</span>(name = <span class="hljs-string">"stringRedisTemplate"</span>)
    <span class="hljs-keyword">private</span> ValueOperations&lt;String, String&gt; valueOperations;
    <span class="hljs-comment">/** 值模式 */</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String KEY_FORMAT = <span class="hljs-string">"Value:Role:%s"</span>;

    <span class="hljs-comment">/** 设置值 */</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">set</span><span class="hljs-params">(Long id, RoleDO value)</span> </span>{
        String key = String.format(KEY_FORMAT, id);
        valueOperations.set(key, JSON.toJSONString(value));
    }

    <span class="hljs-comment">/** 获取值 */</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> RoleDO <span class="hljs-title">get</span><span class="hljs-params">(Long id)</span> </span>{
        String key = String.format(KEY_FORMAT, id);
        String value = valueOperations.get(key);
        <span class="hljs-keyword">return</span> JSON.parseObject(value, RoleDO<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;
    }

    ...
}
</code></pre><p><strong>精简：</strong></p><pre class="highlight"><code class="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AbstractDynamicValue</span>&lt;<span class="hljs-title">I</span>, <span class="hljs-title">V</span>&gt; </span>{
    <span class="hljs-comment">/** 值操作 */</span>
    <span class="hljs-meta">@Resource</span>(name = <span class="hljs-string">"stringRedisTemplate"</span>)
    <span class="hljs-keyword">private</span> ValueOperations&lt;String, String&gt; valueOperations;

    <span class="hljs-comment">/** 设置值 */</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">set</span><span class="hljs-params">(I id, V value)</span> </span>{
        valueOperations.set(getKey(id), JSON.toJSONString(value));
    }

    <span class="hljs-comment">/** 获取值 */</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> V <span class="hljs-title">get</span><span class="hljs-params">(I id)</span> </span>{
        <span class="hljs-keyword">return</span> JSON.parseObject(valueOperations.get(getKey(id)), getValueClass());
    }

    ...

    <span class="hljs-comment">/** 获取主键 */</span>
    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> String <span class="hljs-title">getKey</span><span class="hljs-params">(I id)</span></span>;

    <span class="hljs-comment">/** 获取值类 */</span>
    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> Class&lt;V&gt; <span class="hljs-title">getValueClass</span><span class="hljs-params">()</span></span>;
}

<span class="hljs-meta">@Repository</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserValue</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractValue</span>&lt;<span class="hljs-title">Long</span>, <span class="hljs-title">UserDO</span>&gt; </span>{
    <span class="hljs-comment">/** 获取主键 */</span>
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">protected</span> String <span class="hljs-title">getKey</span><span class="hljs-params">(Long id)</span> </span>{
        <span class="hljs-keyword">return</span> String.format(<span class="hljs-string">"Value:User:%s"</span>, id);
    }

    <span class="hljs-comment">/** 获取值类 */</span>
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">protected</span> Class&lt;UserDO&gt; <span class="hljs-title">getValueClass</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> UserDO<span class="hljs-class">.<span class="hljs-keyword">class</span></span>;
    }
}

<span class="hljs-meta">@Repository</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RoleValue</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractValue</span>&lt;<span class="hljs-title">Long</span>, <span class="hljs-title">RoleDO</span>&gt; </span>{
    <span class="hljs-comment">/** 获取主键 */</span>
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">protected</span> String <span class="hljs-title">getKey</span><span class="hljs-params">(Long id)</span> </span>{
        <span class="hljs-keyword">return</span> String.format(<span class="hljs-string">"Value:Role:%s"</span>, id);
    }

    <span class="hljs-comment">/** 获取值类 */</span>
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">protected</span> Class&lt;RoleDO&gt; <span class="hljs-title">getValueClass</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> RoleDO<span class="hljs-class">.<span class="hljs-keyword">class</span></span>;
    }
}
</code></pre><h3 id="102建造者模式"><a class="markdownIt-Anchor" href="#102建造者模式"></a> <strong>10.2.建造者模式</strong></h3><p>建造者模式（Builder Pattern）将一个复杂对象的构造与它的表示分离，使同样的构建过程可以创建不同的表示，这样的设计模式被称为建造者模式。</p><p><strong>普通：</strong></p><pre class="highlight"><code class="java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">DataHandler</span>&lt;<span class="hljs-title">T</span>&gt; </span>{
    <span class="hljs-comment">/** 解析数据 */</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">parseData</span><span class="hljs-params">(Record record)</span></span>;

    <span class="hljs-comment">/** 存储数据 */</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">storeData</span><span class="hljs-params">(List&lt;T&gt; dataList)</span></span>;
}

<span class="hljs-keyword">public</span> &lt;T&gt; <span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-title">executeFetch</span><span class="hljs-params">(String tableName, <span class="hljs-keyword">int</span> batchSize, DataHandler&lt;T&gt; dataHandler)</span> <span class="hljs-keyword">throws</span> Exception </span>{
    <span class="hljs-comment">// 构建下载会话</span>
    DownloadSession session = buildSession(tableName);

    <span class="hljs-comment">// 获取数据数量</span>
    <span class="hljs-keyword">long</span> recordCount = session.getRecordCount();
    <span class="hljs-keyword">if</span> (recordCount == <span class="hljs-number">0</span>) {
        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
    }

    <span class="hljs-comment">// 进行数据读取</span>
    <span class="hljs-keyword">long</span> fetchCount = <span class="hljs-number">0L</span>;
    <span class="hljs-keyword">try</span> (RecordReader reader = session.openRecordReader(<span class="hljs-number">0L</span>, recordCount, <span class="hljs-keyword">true</span>)) {
        <span class="hljs-comment">// 依次读取数据</span>
        Record record;
        List&lt;T&gt; dataList = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(batchSize);
        <span class="hljs-keyword">while</span> ((record = reader.read()) != <span class="hljs-keyword">null</span>) {
            <span class="hljs-comment">// 解析添加数据</span>
            T data = dataHandler.parseData(record);
            <span class="hljs-keyword">if</span> (Objects.nonNull(data)) {
                dataList.add(data);
            }

            <span class="hljs-comment">// 批量存储数据</span>
            <span class="hljs-keyword">if</span> (dataList.size() == batchSize) {
                <span class="hljs-keyword">boolean</span> isContinue = dataHandler.storeData(dataList);
                fetchCount += batchSize;
                dataList.clear();
                <span class="hljs-keyword">if</span> (!isContinue) {
                    <span class="hljs-keyword">break</span>;
                }
            }
        }

        <span class="hljs-comment">// 存储剩余数据</span>
        <span class="hljs-keyword">if</span> (CollectionUtils.isNotEmpty(dataList)) {
            dataHandler.storeData(dataList);
            fetchCount += dataList.size();
            dataList.clear();
        }
    }

    <span class="hljs-comment">// 返回获取数量</span>
    <span class="hljs-keyword">return</span> fetchCount;
}

 <span class="hljs-comment">// 使用案例</span>
<span class="hljs-keyword">long</span> fetchCount = odpsService.executeFetch(<span class="hljs-string">"user"</span>, <span class="hljs-number">5000</span>, <span class="hljs-keyword">new</span> DataHandler() {
    <span class="hljs-comment">/** 解析数据 */</span>
    <span class="hljs-meta">@Override</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">parseData</span><span class="hljs-params">(Record record)</span> </span>{
        UserDO user = <span class="hljs-keyword">new</span> UserDO();
        user.setId(record.getBigint(<span class="hljs-string">"id"</span>));
        user.setName(record.getString(<span class="hljs-string">"name"</span>));
        <span class="hljs-keyword">return</span> user;
    }

    <span class="hljs-comment">/** 存储数据 */</span>
    <span class="hljs-meta">@Override</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">storeData</span><span class="hljs-params">(List&lt;T&gt; dataList)</span> </span>{
        userDAO.batchInsert(dataList);
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
    }
});
</code></pre><p><strong>精简：</strong></p><pre class="highlight"><code class="java"><span class="hljs-keyword">public</span> &lt;T&gt; <span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-title">executeFetch</span><span class="hljs-params">(String tableName, <span class="hljs-keyword">int</span> batchSize, Function&lt;Record, T&gt; dataParser, Function&lt;List&lt;T&gt;, Boolean&gt; dataStorage)</span> <span class="hljs-keyword">throws</span> Exception </span>{
    <span class="hljs-comment">// 构建下载会话</span>
    DownloadSession session = buildSession(tableName);

    <span class="hljs-comment">// 获取数据数量</span>
    <span class="hljs-keyword">long</span> recordCount = session.getRecordCount();
    <span class="hljs-keyword">if</span> (recordCount == <span class="hljs-number">0</span>) {
        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
    }

    <span class="hljs-comment">// 进行数据读取</span>
    <span class="hljs-keyword">long</span> fetchCount = <span class="hljs-number">0L</span>;
    <span class="hljs-keyword">try</span> (RecordReader reader = session.openRecordReader(<span class="hljs-number">0L</span>, recordCount, <span class="hljs-keyword">true</span>)) {
        <span class="hljs-comment">// 依次读取数据</span>
        Record record;
        List&lt;T&gt; dataList = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(batchSize);
        <span class="hljs-keyword">while</span> ((record = reader.read()) != <span class="hljs-keyword">null</span>) {
            <span class="hljs-comment">// 解析添加数据</span>
            T data = dataParser.apply(record);
            <span class="hljs-keyword">if</span> (Objects.nonNull(data)) {
                dataList.add(data);
            }

            <span class="hljs-comment">// 批量存储数据</span>
            <span class="hljs-keyword">if</span> (dataList.size() == batchSize) {
                Boolean isContinue = dataStorage.apply(dataList);
                fetchCount += batchSize;
                dataList.clear();
                <span class="hljs-keyword">if</span> (!Boolean.TRUE.equals(isContinue)) {
                    <span class="hljs-keyword">break</span>;
                }
            }
        }

        <span class="hljs-comment">// 存储剩余数据</span>
        <span class="hljs-keyword">if</span> (CollectionUtils.isNotEmpty(dataList)) {
            dataStorage.apply(dataList);
            fetchCount += dataList.size();
            dataList.clear();
        }
    }

    <span class="hljs-comment">// 返回获取数量</span>
    <span class="hljs-keyword">return</span> fetchCount;
}

 <span class="hljs-comment">// 使用案例</span>
<span class="hljs-keyword">long</span> fetchCount = odpsService.executeFetch(<span class="hljs-string">"user"</span>, <span class="hljs-number">5000</span>, record -&gt; {
        UserDO user = <span class="hljs-keyword">new</span> UserDO();
        user.setId(record.getBigint(<span class="hljs-string">"id"</span>));
        user.setName(record.getString(<span class="hljs-string">"name"</span>));
        <span class="hljs-keyword">return</span> user;
    }, dataList -&gt; {
        userDAO.batchInsert(dataList);
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
    });
</code></pre><p>普通的建造者模式，实现时需要定义 DataHandler 接口，调用时需要实现 DataHandler 匿名内部类，代码较多较繁琐。而精简后的建造者模式，充分利用了函数式编程，实现时无需定义接口，直接使用 Function 接口；调用时无需实现匿名内部类，直接采用 lambda 表达式，代码较少较简洁。</p><h3 id="103代理模式"><a class="markdownIt-Anchor" href="#103代理模式"></a> <strong>10.3.代理模式</strong></h3><p>Spring 中最重要的代理模式就是 AOP (Aspect-Oriented Programming，面向切面的编程)，是使用 JDK 动态代理和 CGLIB 动态代理技术来实现的。</p><p><strong>普通：</strong></p><pre class="highlight"><code class="java"><span class="hljs-meta">@Slf</span>4j
<span class="hljs-meta">@RestController</span>
<span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"/user"</span>)
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserController</span> </span>{
    <span class="hljs-comment">/** 用户服务 */</span>
    <span class="hljs-meta">@Autowired</span>
    <span class="hljs-keyword">private</span> UserService userService;

    <span class="hljs-comment">/** 查询用户 */</span>
    <span class="hljs-meta">@PostMapping</span>(<span class="hljs-string">"/queryUser"</span>)
    <span class="hljs-keyword">public</span> Result&lt;?&gt; queryUser(<span class="hljs-meta">@RequestBody</span> <span class="hljs-meta">@Valid</span> UserQueryVO query) {
        <span class="hljs-keyword">try</span> {
            PageDataVO&lt;UserVO&gt; pageData = userService.queryUser(query);
            <span class="hljs-keyword">return</span> Result.success(pageData);
        } <span class="hljs-keyword">catch</span> (Exception e) {
            log.error(e.getMessage(), e);
            <span class="hljs-keyword">return</span> Result.failure(e.getMessage());
        }
    }
    ...
}
</code></pre><p><strong>精简1：</strong></p><p>基于 @ControllerAdvice 的异常处理：</p><pre class="highlight"><code class="java"><span class="hljs-meta">@RestController</span>
<span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"/user"</span>)
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserController</span> </span>{
    <span class="hljs-comment">/** 用户服务 */</span>
    <span class="hljs-meta">@Autowired</span>
    <span class="hljs-keyword">private</span> UserService userService;

    <span class="hljs-comment">/** 查询用户 */</span>
    <span class="hljs-meta">@PostMapping</span>(<span class="hljs-string">"/queryUser"</span>)
    <span class="hljs-keyword">public</span> Result&lt;PageDataVO&lt;UserVO&gt;&gt; queryUser(<span class="hljs-meta">@RequestBody</span> <span class="hljs-meta">@Valid</span> UserQueryVO query) {
        PageDataVO&lt;UserVO&gt; pageData = userService.queryUser(query);
        <span class="hljs-keyword">return</span> Result.success(pageData);
    }
    ...
}

<span class="hljs-meta">@Slf</span>4j
<span class="hljs-meta">@ControllerAdvice</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GlobalControllerAdvice</span> </span>{
    <span class="hljs-comment">/** 处理异常 */</span>
    <span class="hljs-meta">@ResponseBody</span>
    <span class="hljs-meta">@ExceptionHandler</span>(Exception<span class="hljs-class">.<span class="hljs-keyword">class</span>)
    <span class="hljs-title">public</span> <span class="hljs-title">Result</span>&lt;<span class="hljs-title">Void</span>&gt; <span class="hljs-title">handleException</span>(<span class="hljs-title">Exception</span> <span class="hljs-title">e</span>) </span>{
        log.error(e.getMessage(), e);
        <span class="hljs-keyword">return</span> Result.failure(e.getMessage());
    }
}
</code></pre><p><strong>精简2：</strong></p><p>基于 AOP 的异常处理：</p><pre class="highlight"><code class="java"><span class="hljs-comment">// UserController代码同"精简1"</span>

<span class="hljs-meta">@Slf</span>4j
<span class="hljs-meta">@Aspect</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WebExceptionAspect</span> </span>{
    <span class="hljs-comment">/** 点切面 */</span>
    <span class="hljs-meta">@Pointcut</span>(<span class="hljs-string">"@annotation(org.springframework.web.bind.annotation.RequestMapping)"</span>)
    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">webPointcut</span><span class="hljs-params">()</span> </span>{}

    <span class="hljs-comment">/** 处理异常 */</span>
    <span class="hljs-meta">@AfterThrowing</span>(pointcut = <span class="hljs-string">"webPointcut()"</span>, throwing = <span class="hljs-string">"e"</span>)
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleException</span><span class="hljs-params">(Exception e)</span> </span>{
        Result&lt;Void&gt; result = Result.failure(e.getMessage());
        writeContent(JSON.toJSONString(result));
    }
    ...
}
</code></pre><h2 id="利用删除代码"><a class="markdownIt-Anchor" href="#利用删除代码"></a> <strong>利用删除代码</strong></h2><p>“少即是多”，“少”不是空白而是精简，“多”不是拥挤而是完美。删除多余的代码，才能使代码更精简更完美。</p><h3 id="111删除已废弃的代码"><a class="markdownIt-Anchor" href="#111删除已废弃的代码"></a> <strong>11.1.删除已废弃的代码</strong></h3><p>删除项目中的已废弃的包、类、字段、方法、变量、常量、导入、注解、注释、已注释代码、Maven包导入、MyBatis的SQL语句、属性配置字段等，可以精简项目代码便于维护。</p><p><strong>普通：</strong></p><pre class="highlight"><code class="java"><span class="hljs-keyword">import</span> lombok.extern.slf4j.Slf4j;
<span class="hljs-meta">@Slf</span>4j
<span class="hljs-meta">@Service</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ProductService</span> </span>{
    <span class="hljs-meta">@Value</span>(<span class="hljs-string">"discardRate"</span>)
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">double</span> discardRate;
    ...
    <span class="hljs-function"><span class="hljs-keyword">private</span> ProductVO <span class="hljs-title">transProductDO</span><span class="hljs-params">(ProductDO productDO)</span> </span>{
        ProductVO productVO = <span class="hljs-keyword">new</span> ProductVO();
        BeanUtils.copyProperties(productDO, productVO);
        <span class="hljs-comment">// productVO.setPrice(getDiscardPrice(productDO.getPrice()));</span>
        <span class="hljs-keyword">return</span> productVO;
    }
    <span class="hljs-function"><span class="hljs-keyword">private</span> BigDecimal <span class="hljs-title">getDiscardPrice</span><span class="hljs-params">(BigDecimal originalPrice)</span> </span>{
        ...
    }
}
</code></pre><p><strong>精简：</strong></p><pre class="highlight"><code class="java"><span class="hljs-meta">@Service</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ProductService</span> </span>{
    ...
    <span class="hljs-function"><span class="hljs-keyword">private</span> ProductVO <span class="hljs-title">transProductDO</span><span class="hljs-params">(ProductDO productDO)</span> </span>{
        ProductVO productVO = <span class="hljs-keyword">new</span> ProductVO();
        BeanUtils.copyProperties(productDO, productVO);
        <span class="hljs-keyword">return</span> productVO;
    }
}
</code></pre><h3 id="112删除接口方法的public"><a class="markdownIt-Anchor" href="#112删除接口方法的public"></a> <strong>11.2.删除接口方法的public</strong></h3><p>对于接口(interface)，所有的字段和方法都是 public 的，可以不用显式声明为 public 。</p><p><strong>普通：</strong></p><pre class="highlight"><code class="java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">UserDAO</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> Long <span class="hljs-title">countUser</span><span class="hljs-params">(@Param(<span class="hljs-string">"query"</span>)</span> UserQuery query)</span>;
    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;UserDO&gt; <span class="hljs-title">queryUser</span><span class="hljs-params">(@Param(<span class="hljs-string">"query"</span>)</span> UserQuery query)</span>;
}
</code></pre><p><strong>精简：</strong></p><pre class="highlight"><code class="java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">UserDAO</span> </span>{
    <span class="hljs-function">Long <span class="hljs-title">countUser</span><span class="hljs-params">(@Param(<span class="hljs-string">"query"</span>)</span> UserQuery query)</span>;
    <span class="hljs-function">List&lt;UserDO&gt; <span class="hljs-title">queryUser</span><span class="hljs-params">(@Param(<span class="hljs-string">"query"</span>)</span> UserQuery query)</span>;
}
</code></pre><h3 id="113删除枚举构造方法的-private"><a class="markdownIt-Anchor" href="#113删除枚举构造方法的-private"></a> <strong>11.3.删除枚举构造方法的 private</strong></h3><p>对于枚举(menu)，构造方法都是 private 的，可以不用显式声明为 private 。</p><p><strong>普通：</strong></p><pre class="highlight"><code class="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> UserStatus {
    DISABLED(<span class="hljs-number">0</span>, <span class="hljs-string">"禁用"</span>),
    ENABLED(<span class="hljs-number">1</span>, <span class="hljs-string">"启用"</span>);
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Integer value;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String desc;
    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">UserStatus</span><span class="hljs-params">(Integer value, String desc)</span> </span>{
        <span class="hljs-keyword">this</span>.value = value;
        <span class="hljs-keyword">this</span>.desc = desc;
    }
    ...
}
</code></pre><p><strong>精简：</strong></p><pre class="highlight"><code class="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> UserStatus {
    DISABLED(<span class="hljs-number">0</span>, <span class="hljs-string">"禁用"</span>),
    ENABLED(<span class="hljs-number">1</span>, <span class="hljs-string">"启用"</span>);
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Integer value;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String desc;
    UserStatus(Integer value, String desc) {
        <span class="hljs-keyword">this</span>.value = value;
        <span class="hljs-keyword">this</span>.desc = desc;
    }
    ...
}
</code></pre><h3 id="114删除-final-类方法的-final"><a class="markdownIt-Anchor" href="#114删除-final-类方法的-final"></a> <strong>11.4.删除 final 类方法的 final</strong></h3><p>对于 final 类，不能被子类继承，所以其方法不会被覆盖，没有必要添加 final 修饰。</p><p><strong>普通：</strong></p><pre class="highlight"><code class="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> Rectangle implements Shape {
    ...
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">double</span> <span class="hljs-title">getArea</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> width * height;
    }
}
</code></pre><p><strong>精简：</strong></p><pre class="highlight"><code class="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> Rectangle implements Shape {
    ...
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">getArea</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> width * height;
    }
}
</code></pre><h3 id="115删除基类-implements-的接口"><a class="markdownIt-Anchor" href="#115删除基类-implements-的接口"></a> <strong>11.5.删除基类 implements 的接口</strong></h3><p>如果基类已 implements 某接口，子类没有必要再 implements 该接口，只需要直接实现接口方法即可。</p><p><strong>普通：</strong></p><pre class="highlight"><code class="java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Shape</span> </span>{
    ...
    <span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">getArea</span><span class="hljs-params">()</span></span>;
}
<span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> AbstractShape implements Shape {
    ...
}
<span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> Rectangle extends AbstractShape implements Shape {
    ...
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">getArea</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> width * height;
    }
}
</code></pre><p><strong>精简：</strong></p><pre class="highlight"><code class="java">...
<span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> Rectangle extends AbstractShape {
    ...
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">getArea</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> width * height;
    }
}
</code></pre><h3 id="116删除不必要的变量"><a class="markdownIt-Anchor" href="#116删除不必要的变量"></a> <strong>11.6.删除不必要的变量</strong></h3><p>不必要的变量，只会让代码看起来更繁琐。</p><p><strong>普通：</strong></p><pre class="highlight"><code class="java"><span class="hljs-function"><span class="hljs-keyword">public</span> Boolean <span class="hljs-title">existsUser</span><span class="hljs-params">(Long userId)</span> </span>{
    Boolean exists = userDAO.exists(userId);
    <span class="hljs-keyword">return</span> exists;
}
</code></pre><p><strong>精简：</strong></p><pre class="highlight"><code class="java"><span class="hljs-function"><span class="hljs-keyword">public</span> Boolean <span class="hljs-title">existsUser</span><span class="hljs-params">(Long userId)</span> </span>{
    <span class="hljs-keyword">return</span> userDAO.exists(userId);
}
</code></pre><h2 id="后记"><a class="markdownIt-Anchor" href="#后记"></a> <strong>后记</strong></h2><p>古语又云：</p><blockquote><p>有道无术，术尚可求也；有术无道，止于术。</p></blockquote><p>意思是：有“道”而无“术”，“术”还可以逐渐获得；有“术”而无“道”，就可能止步于“术”了。所以，我们不要仅满足于从实践中总结“术”，因为“道”的表现形式是多变的；而应该上升到“道”的高度，因为“术”背后的道理是相通的。当遇到新的事物时，我们可以从理论中找到“道”、从实践中找出“术”，尝试着去认知新的事物。</p><p>本文作者：陈昌毅，花名常意，地图技术专家。</p></div><hr><div><p><span><i class="iconfont icon-inbox"></i> <a class="hover-with-bg" href="/categories/Java/">Java</a> &nbsp; </span>&nbsp;&nbsp; <span><i class="iconfont icon-tag"></i> <a class="hover-with-bg" href="/tags/Java/">Java</a></span></p><p class="note note-warning">本博客所有文章除特别声明外，均采用 <a href="https://zh.wikipedia.org/wiki/Wikipedia:CC_BY-SA_3.0%E5%8D%8F%E8%AE%AE%E6%96%87%E6%9C%AC" target="_blank" rel="nofollow noopener noopener">CC BY-SA 3.0协议</a> 。转载请注明出处！</p><div style="display:flex;justify-content:space-between"><div align="left"></div><div align="right"><a href="/20200421/biological-compulsory-two-outline.html">生物必修二提纲&nbsp<i class="iconfont iconrightarrow"></i></a></div></div></div><div class="comments" id="comments"><div id="vcomments"></div><script defer src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script defer src="https://cdn.staticfile.org/valine/1.4.4/Valine.min.js"></script><script type="text/javascript">var notify=!1,verify=!1,oldLoadVa=window.onload;window.onload=function(){oldLoadVa&&oldLoadVa(),new Valine({el:"#vcomments",notify:notify,verify:verify,app_id:"iJ9YWur9WXEHRtV80LJLFOr2-gzGzoHsz",app_key:"eGXXmoTvBtzHmwAzSNE6dD0g",placeholder:"说点什么（邮箱用于回复邮件通知）",avatar:"/retro",meta:["nick","mail","link"],pageSize:"10"})}</script><noscript>Please enable JavaScript to view the <a href="https://valine.js.org" target="_blank" rel="nofollow noopener noopener">comments powered by Valine.</a></noscript></div></div></div></div></div><div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn"><div id="toc-start"></div><div id="toc"><p class="h5"><i class="far fa-list-alt"></i>&nbsp;目录</p><div id="tocbot"></div></div></div></div></div><script type="text/javascript">function showSnackbar(e){var o=document.getElementById("snackbar");o.innerHTML=e,o.className="show",setTimeout(function(){o.className=o.className.replace("show","")},3e3)}function closeDarkMode0(){document.body.classList.remove("dark"),document.cookie="dark=0;path=/",bgView.style.backgroundImage="url(https://cdn.jsdelivr.net/gh/wtrwx/wtrwxIMG/background.png )";var e="80";header.style.height=e+"%"}function openDarkMode1(){document.body.classList.add("dark"),document.cookie="dark=1;path=/",bgView.style.backgroundImage="",header.style.height="50%"}function closeDarkMode2(){document.body.classList.remove("dark"),document.cookie="dark=2;path=/",bgView.style.backgroundImage="url(https://cdn.jsdelivr.net/gh/wtrwx/wtrwxIMG/background.png )";var e="80";header.style.height=e+"%"}function openDarkMode3(){document.body.classList.add("dark"),document.cookie="dark=3;path=/",bgView.style.backgroundImage="",header.style.height="50%"}function switchDarkMode(){var e=document.cookie.replace(/(?:(?:^|.*;\s*)dark\s*\=\s*([^;]*).*$)|^.*$/,"$1"),o=new Date,a=o.getHours();a>=21||7>a?"1"==e||"3"==e?closeDarkMode2():"2"==e&&openDarkMode1():"0"==e||"2"==e?openDarkMode1():("1"==e||"3"==e)&&closeDarkMode0()}var header=document.getElementById("header"),bgView=document.getElementById("background");!function(){var e=new Date,o=e.getHours(),a=document.cookie.replace(/(?:(?:^|.*;\s*)dark\s*\=\s*([^;]*).*$)|^.*$/,"$1");"app/WtrwxFluid"==navigator.userAgent&&(document.getElementById("header").style.height="0",document.getElementById("navbar").style.display="none",document.getElementById("darkmode").style.display="none"),matchMedia("(prefers-color-scheme: dark)").matches?openDarkMode3():o>=21||7>o?""==a||"0"==a||"1"==a||"3"==a?openDarkMode3():"2"==a&&closeDarkMode2():(""==a||"0"==a||"3"==a?closeDarkMode0():"2"==a&&closeDarkMode2(),"1"==a&&openDarkMode1())}()</script></main><a id="scroll-top-button" href="#" role="button"><i class="iconfont iconFontAwesomechevronup scroll-top-arrow" aria-hidden="true"></i></a><div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">搜索</h4><button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"><input type="text" id="local-search-input" class="form-control validate"><label data-error="x" data-success="v" for="local-search-input">关键词</label></div><div class="list-group" id="local-search-result"></div></div></div></div></div><footer class="mt-5"><div class="text-center py-3"><div><a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a></div></div></footer><script src="https://cdn.staticfile.org/jquery/3.4.1/jquery.min.js"></script><script src="https://cdn.staticfile.org/popper.js/1.16.1/umd/popper.min.js"></script><script src="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/js/bootstrap.min.js"></script><script src="/js/main.js"></script><script src="/js/lazyload.js"></script><script src="https://cdn.staticfile.org/tocbot/4.11.1/tocbot.min.js"></script><script>$(document).ready(function(){var t=$("#navbar").height(),o=$("#toc"),s=$("#board-ctn"),c=s.offset().top,i=2*c+s.height();$(window).scroll(function(){var s=$("#toc-start").offset().top-t,c=document.body.scrollTop+document.documentElement.scrollTop;c>=s&&i>=c?o.css({display:"block",position:"fixed",top:t}):s>=c?o.css({position:"",top:""}):c>i&&o.css("display","none")}),tocbot.init({tocSelector:"#tocbot",contentSelector:".post-content",headingSelector:"h1,h2,h3,h4,h5,h6",linkClass:"tocbot-link",activeLinkClass:"tocbot-active-link",listClass:"tocbot-list",isCollapsedClass:"tocbot-is-collapsed",collapsibleClass:"tocbot-is-collapsible",scrollSmooth:!0,headingsOffset:-c}),$(".toc-list-item").length>0&&$("#toc > p").css("visibility","visible");var l=s.css("margin-right");$("#toc-ctn").css({right:l})})</script><script defer src="https://cdn.staticfile.org/clipboard.js/2.0.6/clipboard.min.js"></script><script src="/js/clipboard-use.js"></script><script defer>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?aa1ed1fa44c953457a7f380ebae26f68";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><script src="https://cdn.staticfile.org/prettify/188.0.0/prettify.min.js"></script><script>$(document).ready(function(){$("pre").each(function(){const n=$(this);n.find("code.mermaid").length>0||n.addClass("prettyprint  linenums")}),prettyPrint()})</script><script src="https://cdn.staticfile.org/typed.js/2.0.11/typed.min.js"></script><script>var typed=new Typed("#subtitle",{strings:["  ","Java代码精简之道&nbsp;"],cursorChar:"_",typeSpeed:70,loop:!1});typed.stop(),$(document).ready(function(){$(".typed-cursor").addClass("h2"),typed.start()})</script><script src="https://cdn.staticfile.org/anchor-js/4.2.2/anchor.min.js"></script><script>anchors.options = {
      placement: "right",
      visible: "false",
      
    };
    var el = "h1,h2,h3,h4,h5,h6".split(",");
    var res = [];
    for (item of el) {
      res.push(".markdown-body > " + item)
    }
    anchors.add(res.join(", "))</script><script src="/js/local-search.js"></script><script>var path="/local-search.xml",inputArea=document.querySelector("#local-search-input");inputArea.onclick=function(){getSearchFile(path),this.onclick=null}</script><script defer src="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.js"></script><script>$("#post img:not(.no-zoom img, img[no-zoom])").each(function(){var t=document.createElement("a");$(t).attr("class","src"),$(t).attr("data-fancybox","images"),$(t).attr("href",$(this).attr("src")),$(this).wrap(t)})</script><div align="center"><button id="darkmode" class="rkmd-btn btn-flat ripple-effect" onclick="switchDarkMode()">Day/Night</button></div><script type="text/javascript">!function(){if("app/WtrwxFluid"==navigator.userAgent){document.getElementById("darkmode").style.display="none";var e=document.getElementsByClassName("src");for(var n in e)e[n].onclick=function(){return!1}}}()</script></body></html><!-- rebuild by neat -->